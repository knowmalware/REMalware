# DLL Analysis

While it's likely that malware will call on standard Windows DLLs to accomplish its goals, it is not uncommon to use custom DLLs during execution. The DLLs may be loaded using the `LoadLibrary` / `GetProcAddress` approach, or they may be injected, in which case it is common that the DLLMain function takes over and runs without further intervention.

## Execution

### DllMain

DllMain is the entry-point function of a DLL, which is responsible for initialization of any global variables provided by the library. It is useful to know that when DllMain is called, the loader provides three arguments to this initialization function. The function prototype looks like this:
```
    BOOL WINAPI DllMain(
      __in  HINSTANCE hinstDLL,
      __in  DWORD fdwReason,
      __in  LPVOID lpvReserved
    );
```

The fdwReason argument identifies for what reason the DLL was loaded.
```
    #define DLL_PROCESS_DETACH 0
    #define DLL_PROCESS_ATTACH 1
    #define DLL_THREAD_ATTACH 2
    #define DLL_THREAD_DETACH 3
```

### Exports

While malware DLLs often do their dirty work from DLLMain, the exports of the DLL shouldn't be overlooked. In IDA Pro they can be found in both the Exports window as well as the Entry Points dialog (which **Ctrl-E** reveals) to provide quick access.

### Executing DLLs in a Debugger

At times you may want to analyze a DLL in a debugger. IDA Pros debugger requires an executable to be designated for loading the DLL (e.g. rundll32), while OllyDbg and x64dbg automatically handle loading the DLL with a stub program.

It is also possible to treat the DLL like an executable. In your favorite PE editor (e.g. CFF Explorer), disable:
```
    IMAGE_FILE_HEADER->Characteristics IMAGE_FILE_DLL flag (0x1000)
```
Remember that DllMain expects 3 arguments, so if the DLL is treated as in executable, the main function may try to access arguments that don't exist (as they are not available to an executable).


## Example

By now you have unpacked `bserver.ex_` (and we'll assume you named the dump `bserver.unpacked.ex_`). The exe uses a DLL and this example will discuss:

- Identifying the use of the DLL
- Tracing back to the DLL drop site
- How to extract the DLL
- Brief analysis of the DLL

### Walkthrough

#### From Executable to DLL
1. Open `bserver.unpacked.ex_` in IDA
  - Note `CreateProcess`
1. Examine three user-defined functions
  1. first reads the current file (Discuss tracing name arg back to `GetModuleHandleA`)
  1. Second is string manip
  1. Third refers to a DLL and performs file operations (rb and Wb!)
1. Put breakpoint on function
1. `F9` to begin
  - Crash! What's up?!
  - We are running the unpacked file, and it is reading itself...
1. Add breakpoint on first user-defined function
1. Restart
1. Patch the name in memory to open the original file
1. Start up [Procmon](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon)
  1. filter on our process (`bserver.unpacked.ex_`)
  1. drop filtered events
  1. clear log
1. Run to 2nd breakpoint
1. Step Over
  - We see `c:\windows\system32\berzk.dll` has been dropped
1. Stop process

#### Unpacking the Dropped DLL
1. open in CFF Explorer
  - has no exports
    - this means functionality should all be in main
1. Change FileHeader -> Characteristics: Uncheck File is a DLL
1. Click OK, and Save
1. Open dll in ImmDbg
1. Find tail jump, break and step
  - NOTHING?!
1. Restart
1. Initial check is checking to see how the DLL was loaded
1. Move origin to after jnz
  - or, single-step until jnz, then set ZF to 1
1. Run to break
1. Single Step to OEP
1. dump

#### Analyzing the Dumped DLL
Our dump should maintain the DLL "unsetting" we did for the packed DLL so if clean dump, we can execute it

1. Load into IDA
  - Note the jumps at and around entry (DllMain)
  - Visual studio Incremental Link Option (/INCREMENTAL) causes this (thunks for author's functions)
1. Click DllMain jmp address
  - Note several disconnected graphs
  - Goofy IDA analysis is a result of function thunks
1. Delete function
1. Step back to thunks
1. Scroll up to first thunk
1. Recreate functions with script:
    ```
        auto start, end, a, xref;

        start = 0x10001005;
        end = 0x100010AF;

        for( a = start; a < end; a = a + 5 ) {
          xref = Rfirst( a );
          MakeFunction( xref, BADADDR );
          Message( "%08x: Made function\n", xref );
        }
    ```
  - Note: If you try to execute there is an exception loading `RtlRestoreLastWin32Error`
    - OllyDumpEx missed something. It wasn't aware of a Forward from kernel32 to ntdll
1. Open DLL in CFF Explorer
1. Find `RtlRestoreLastWin32Error`
1. Change name to: `SetLastError`
  - Should run properly now
