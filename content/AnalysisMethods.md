
Dynamic
=======

Generally used as a first pass attempt to understand a piece of software, Sandboxing uses an *Execute and Monitor* approach to understand observable behavior, and in the case of malware, the *Initial Indicators of Compromise*.

Limitations
-----------

Dynamic Analysis is a task that is repeatable and is often automated to perform unattended analysis when the analysis resources are limited and volume of malware to analyze is high. In such cases, outcomes can be limited because the software being analyzed:

- requires input (e.g. stdin, command line arguments)
- has Anti-Analysis built-in
- delays execution

An automated Dynamic Analysis system needs to define its limits such as:

- run-time allowed for each piece of malware
- the software and patch levels available in the execution environment
- the capabilities of their monitoring tools

Further leveraging Dynamic Techniques
-------------------------------------

Debugging, another form of Dynamic analysis, may be used after other methods, for example, to monitor command and control behavior and network communication. For instance, assume initial dynamic analysis completes with a network beacon which is not replied to. Static analysis may reveal the communication protocol of the malware, and then use dynamic analysis to interact with it to discover other behavior.


Static
======

Static analysis refers to any investigation of software without execution of it. This can be as simple as collecting meta-data (e.g. file size, file type, sha256 hash) for Triage or as detailed as analyzing every byte for its meaning.

Uses
----
- File Meta Data
    - File Type
    - File Hashes (e.g. md5, sha1)
    - File Size
    - Anti-Virus detection
    - Packer detection
- Finding Dependencies (Imports)
- String Analysis
- Code Analysis

Pros
----
- "Unlimited" access to software capabilities and configuration
- No infection to clean

Cons
----
- Requires deep tool knowledge
- Time Consuming

Deeper Analysis
---------------

Execution does not guarantee that all code paths are followed as software may require a specific environment or inputs to leverage its capabilities. For example, a Bot may do nothing but open a listening socket if you execute it; but if you investigate the code within the executable, you'll find it can list files, execute commands, and send requests to remote hosts (perhaps for a Denial of Service attack).

### Disassembly

Such analysis requires a Disassembler, and though there are several available, IDA Pro is one of the most popular, if not the industry standard, and will be discussed throughout the course.


Emulation
=========

Emulation is related to dynamic analysis. Before most processors supported virtualization, emulation was the only way to run virtual machines; the whole architecture, from registers to PCI bridge to hard drive were all emulated by a program or programs. Even with support for processor virtualization extensions, today's virtualization software (VMware, VirtualBox, Qemu) emulates parts of the virtual system, such as video cards and hard drives. This provides portability.

Emulation in the context of malware analysis, however, is less often about full-system emulation and more often about small parts of code. The emulation program only has to take care of processor and memory in this instance. An exception to this is IDA Pro's option to use [Bochs](http://bochs.sourceforge.net/) as a debugger.

The most popular scriptable emulator these days is [Unicorn](https://www.unicorn-engine.org/). Some old tools may still exist that use libemu or pyemu, so be aware that they exist, but Unicorn-based tools are (have?) quickly replacing them.

Problems
--------

Just as with static, debug, and sandbox analysis, anti-analysis techniques exists for emulation. Often this can be simple detection due to the differences between emulated and real hardware. However, emulation can also be stopped by use of uncommon opcodes and API calls. Emulation also suffers from a slowdown, so massive looping can make it infeasible.


Symbolic
========

Symbolic analysis takes a mathematical view of a program and attempts to apply formula solving techniques in order to answer questions such as, "What arguments to this program will make it reach this specific function?"  It is still in its infancy for malware analysis, with many more examples from academic publishings than from the real world. However, this is a technique to keep an eye on. The [IDA Pro Plugin Contest](https://www.hex-rays.com/contests/index.shtml) named [Ponce](https://github.com/illera88/Ponce) the winner of 2016. Ponce aims to provide "users the ability to perform taint analysis and symbolic execution over binaries in an easy and intuitive fashion."

Symbolic suffers from the same problems as Emulation, but adds something called *state explosion*. This means that some code can be too complex for symbolic analysis to produce a result without a lot of memory and time.

