# Network Communication

## Introduction

### Goals for this section
1. Identify functions responsible for network communication.
1. Introduce the concept of good network signatures.

### Purpose of networking code in malware
- Reconnaissance (e.g. scanning for services)
- Exploit Delivery
- Command and Control (C2)

### How to detect
If the intruder uses a specific tool, technique, or procedure, then it is likely possible to fingerprint

### Command and Control
While each of the listed purposes of networking code offers an opportunity to detect and prevent an intrusion, we will focus on remote access tool (RAT) analysis in our examples and exercises.


## Finding the Code

### Isn't dynamic analysis easier?
Dynamic analysis could yield a C2 callback, or insight into the C2 protocol, and takes much less knowledge of Assembly than does Static analysis. But what if the malware waits for thirty minutes before it starts beaconing? What if it is virtual machine aware? What if it waits until a specific user-controlled process is running before it attempts any outgoing connections?

### How to find the networking code
Refer to the previous Downloaders section (or if you have [Practical Malware Analysis](https://nostarch.com/malware), p313), which lists common API calls that any MS-Windows program, including malware, might use for network communication. The simplest thing to do is to load your malware with IDA and look through the Imports table for any functions that you know are used in network communication, such as `send()` and `recv()`.

### Exercises
1. Use `nba_implant_exe` to answer the following questions:
    1. Which API functions are used to “send” and “recv” data?
    1. Are you sure? Look for calls to LoadLibraryA and revise your previous answers.
    1. Take a look at the call to recv(). What can you say about the packets that it receives?
1. This is a thought exercise rather than a hands-on.
    - When malware uses recv() and send() for network communication, it has control over the exact bytes that are sent in the payload of the TCP or UDP packets. When malware uses URLDownloadToFile, it lets the local IE instance choose which HTTP headers are sent over the network and in which order.  What other API calls can be used for network communication, and how do they affect what is seen on the network? Look at the arguments to the API calls. Put another way, for each API call, what does the malware author have control over, and what not?


## Command and Control (C2)

Understanding a remote access tool (RAT) is all about understanding its network communication. All RATs are broken into two pieces, an implant, which is placed on the compromised system, and a controller, which the intruder uses to control the implant. The network communication is then one of four types:

- the implant requesting a command / action
- the controller providing a command / action
- the implant responding to the given command / action
- keep-alives or "pings"

### Example

Using `nba_implant_exe`, find the function that calls the `recv()` API and view it graphically using:

- **View -> Graphs -> Flow chart**,
- or simply press `F12`.

What you have found is one example of command-code processing, involving a jump table.

Another example is a series of if..else statements, which could look like the following:
```asm
    push 0
    push 0x20
    push offset buf
    push socket
    call recv
    cmp [buf], 1
    jz 0x401ded
    cmp [buf], 2
    jz 0x401eff
    cmp [buf], 3
    jz 0x401fed
    jmp 0x401ace
```

This block of code calls the `recv()` function and then tests the first byte of the buffer for specific values, jumping to specific functionality for each value.

For extra credit, what rookie programming mistake is in the previous block of code?


## Indicators

Creating low false positive, low false negative signatures can be difficult.

The best indicators come from hard-coded, static strings in the malware. For example, when the C2 is tunneled over HTTP and is using a unique User-Agent string, the string can be turned into a simple NIDS signature.

When there are no strings that would yield a low false positive signature, attributes of the C2 can sometimes be used to create effective, though higher false positive, signatures.

**Examples:**

- Constant packet size
    - 5 successive packets within a flow have `dsize: 1234;`
- Specific range of size for the HTTP requested resource
    - `urilen: 128<>160,raw;`
- Specific data encoding, like base64 (see p320)
    - `pcre:"/([a-zA-Z0-9+\/=]{4})+/"`

**WARNING: Know where your signatures will be used!**  For example, HTTP communication through a proxy can change the headers or the requested resource depending on which side of the proxy the signature is implemented. Pre-proxy means the requested resource is a full URL, with protocol and domain name. Post-proxy means possible additional headers added by the proxy, such as `X-Forwarded-For` or `Via`.

*Don't give up if the C2 is encrypted.*  Depending on the chosen encryption algorithm or implementation, a reasonable signature is still possible. For example, if the attacker is using RC4, has embedded the key in the malware itself, and the pre-encrypted C2 has well-defined fields that are NULL padded, you can pick an offset into the data that you know will always be NULL bytes before encryption and compute their encrypted values. Then a simple NIDS signature can be used to test for those specific bytes at the chosen offset.
