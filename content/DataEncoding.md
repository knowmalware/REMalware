About
=====

Purpose
-------
- Evading Detection
- Increase Analysis Complexity

Oft Encoded Data
----------------
- Network Traffic (e.g. RAT command and control)
- Strings (e.g. Domain Name, File Names, Registry Keys)
- Payloads (e.g. Files and Shellcode)


Code Features
=============

The following are common charateristics of encoding and decoding functions.

- **Loop**
- **reads AND writes** data from memory
  - Likely reads are from an address passed as a pointer function arg
  - `mov reg1, [reg2];` (...code for processing...); `mov [reg2], reg1; inc reg2;`
  - `[ base + scale * index ]`
  - `esi / edi (lods, stos)`
- *Sometimes* many xrefs, such as when there are many strings to encode or decode
  - Except when all strings are processed at one time
  - Enables you to quickly decode all strings by iterating over xrefs


Common Algorithms
=================

Common block/byte transformations
---------------------------------

### Caesar Cipher (character/bit add)
- Attributed to Julius Caeser
- Uses an ordered alphabet and translates each letter by addition
  - Caesar used an Add 3 ('A' becomes 'D')
- Wraps around at the end of the alphabet
  - ('X' -> 'A', 'Y' -> 'B', 'Z' -> 'C')
- Typical assembly implementation is an Add of byte values (e.g. add al, 0x03)

![Image showing Caesar cipher using Add 3](800px-Caesar3.svg.png "Figure 1: Caesar Cipher using Add 3")

### XOR and variations
- Using IDA and `4a29d41dfda9cfcbcde4d42b4bbb00aa.ex_`
  1. Search (**Alt-T**) for `xor` with **find all instances**
  2. Which addresses are not simply clearing a register?
    - **TIP**: if you don't search with find all instances, then make sure you put the cursor at the start of the program, otherwise it won't search all the code.
- Load `mspmsnsv.dl_` into IDA (originally from [contagiodump.blogspot.com](https://contagiodump.blogspot.com/2011/04/apr-8-cve-2011-0611-flash-player-zero.html))
  1. Which function contains the XOR loop?
  2. How does it differ from a simple, static, one-byte XOR loop?

### Base64
- Used in legitimate network communication (e.g. MIME-encoded e-mail)
- Often characterized by presence of decoding dictionary or "alphabet" such as:
  - ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
- Example 1
  1. Open `WEBC2-CLOVER_sample\WEBC2-CLOVER_sample_065E63AFDFA539727F63AF7530B22D2F` in IDA.
  1. Go to start of binary.
  1. Perform Binary Search (Alt+B) for “ABCDEFGHIJKLMNOP” (include double-quotes).
  1. Load binary into PEiD.
  5. Run the Krypto Analyzer plugin.
  6. Compare results of IDA search and PEiD analysis.
  7. Try the above with `WEBC2-CSON_sample_A38A367D6696BA90B2E778A5A4BF98FD`. What is different about the WEBC2-CSON binary?
- Example 2
  1. Use the **entropy-finder.py** script on `WEBC2-CSON_sample_A38A367D6696BA90B2E778A5A4BF98FD`.
  2. Use a **length of 64** and a **threshold of 6**.
  3. Load `WEBC2-CSON_sample_A38A367D6696BA90B2E778A5A4BF98FD` into IDA and view the address identified.
      - this is a custom base64 alphabet
  4. Replicate this process with **Old2008-2010\_\_A6C1595BD7B1A85C42FBD674460DC35D\_iprinp.dl\_**. What do you find?

### Encryption
- DES
- AES
- Camellia
- RC4
- Example 1
  1. Reload `4a29d41dfda9cfcbcde4d42b4bbb00aa.ex_` into **PEiD** and run the **Krypto Analyzer plugin** on it again.
  2. Run **entropy-finder.py** on it, as above.
  3. Compare the results.
- Example 2
  1. Load `4a29d41dfda9cfcbcde4d42b4bbb00aa.ex_` into PEiD.
  2. Run the Krypto Analyzer plugin.
    - click **Export**
    - **To File**
    - **IDC Script - Bookmarks and Comments**
  3. Load the binary into IDA.
  4. Load and run the previously saved IDC script.

### Compression
- zlib (RFC 1950) sticks a header onto the compressed data, so seeing one of the following sequences of bytes at the start of a buffer could indicate that it is zlib compressed:
  - `x78 x9c`
  - `x78 xda`
  - `x78 x5e`
  - `x78 x01`
- Example
  1. Load `WEBC2-CLOVER_sample_065E63AFDFA539727F63AF7530B22D2F` into PEiD.
  2. Run Krypto Analyzer plugin.

### String encoding
- ASCII
- Unicode
  - UTF-16 (*widechar* in Windows is utf16le, a little-endian form of UTF-16)
  - UTF-8
  - UTF-32


String obfuscation
------------------
The methods that can be used to obfuscation network traffic can also be used to obfuscate strings, files, or blocks of code.

There are other methods of hiding information in a binary. One method is via MOV instructions:

```
    mov ecx, 0x400000
    mov [ecx], 0x53      // 'S'
    inc ecx
    mov [ecx], 0x54      // 'T'
    inc ecx
    mov [ecx], 0x52      // 'R'
    inc ecx
    mov [ecx], 0x00
```

This sequence puts the ASCII string "STR" at the memory location 0x400000.

A variant of this is to construct the string via one or more PUSH instructions.  For example `PUSH 0x00525453`.  Note that the operand to PUSH looks like it is backwards, but will be stored in memory (i.e. the stack) little-endian.

### Exercise
1. Load `WEBC2-UGX_sample_8462A62F13F92C34E4B89A7D13A185AD` into IDA.
2. Look at the `sub_406044()` function.
3. What are the ASCII strings created in the above described manner?
  - What can you infer about this malware based on these strings?


Decoding
========

As mentioned previously, there are many ways to encode strings with a binary. Sometimes, it’s easier to run the malware in a debugger and put a breakpoint immediately after the string is decoded. Other times, you’ll need to write your own script or program to decode the data.

There are [several options](https://github.com/rshipp/awesome-malware-analysis#debugging-and-reverse-engineering) for writing your own script. On MS-Windows, some examples are:

- [Immunity Debugger](https://www.immunityinc.com/products/debugger/)
- [WinDbg](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools)
- [OllyDbg](http://www.ollydbg.de/) with OllyScript plugin
- [x64dbg](https://x64dbg.com/)
- [IDA Pro](https://www.hex-rays.com/products/ida/)

It is also possible to extract the bytes of a self-contained function from malware and [call it directly using C](https://www.google.com/search?q=executing+shellcode+in+c) or an emulator such as [Unicorn Engine](https://www.unicorn-engine.org/).

We will be using Immunity Debugger for the following example, as it is freely available and relatively simple to use.

Exercise
--------
Open `nba_implant_exe` in IDA and take a look at **WinMain()**. It appears that there is a reference to an encoded string in the first part of the function.

1. Which function is the decode function?
2. How many arguments does this function take?
3. Where would we put a breakpoint to read the decoded string?
4. This sample of malware is not preventing us from simply running the code from the start of WinMain(). However, assume that it is. How can we execute just the part of the code that decodes this string?

Walkthrough: Script the Decoding
--------------------------------
- Open notepad.exe
    ```python
        import immlib
        def main(args):
            imm = immlib.Debugger()
            imm.setReg(“EIP”, 0x401046)
            imm.setBreakpoint(0x401068)
            imm.run()
    ```

- Save As `nba_decode_str.py`
- Copy to `c:\program files\Immunity...\PyCommands\`
- Run Immunity Debugger
  - Open `nba_implant_exe`
  - Look at encoded string
  - In the box at the bottom: `!nba_decode_str`
  - Look at decoded string

Read [Practical Malware Analysis](https://nostarch.com/malware)'s pp291-294 and [Lab13-2](https://practicalmalwareanalysis.com/labs/) for more examples.


Tools
=====

Use these tools to identify different data encoding libraries. Scripting languages can be used to quickly decode strings (idc, python).

- PEiD's KANAL plugin
- IDA Pro's FindCrypt2 plugin
- IDA Pro's Entropy plugin / tool
