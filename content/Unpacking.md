# Unpacking

## About

### Background

- Packers were first created at a time when network bandwidth expensive
- UPX was a cheap way to obscure identifiable strings form Anti-Virus
- As an added bonus, it increases the complexity of analysis
- Packers progressed to Executable Protectors which use additional Anti-Analysis tricks

### Packing Process

- Packers parse the executable's headers
- Code and data is compressed/encrypted/encoded at a block level (e.g. PE section, function, string)
- A new executable is created with the encoded data and modified headers
- An unpacking program (stub) is inserted into the new file and the Entry Point points to it

### The Unpacking Stub

- The code and data is decoded
- Executable loader functions generally performed by the OS are emulated
  - Import functions are resolved assuming the packer encoded them
- Execution is transferred to the original applications code

### Detecting Packers

- Packed applications tend to have a higher level of entropy because compressed data tends to lack structure
  - Entropy is a measure of "randomness" or lack of structure in a file
  - Mandiant's Red Curtain detects entropy and malformity in executable files revealing a "Threat Score"
- Unusual Section Names
- Open in Debugger / Disassembler
  - Ollydbg and IDA Pro sometimes identify that code may be packed


## Categories

### Extension

Extra packer code is executed.

- compressor: reduce original data's size
  - common: aPLib (FSG, , LZMA, NRV/UPX)
  - others: JCALG1, BriefLZ, LZMAT
- protector: makes reverse engineering harder
  - countermeasures:
    - anti-debugging: IsDebuggerPresent, ...
    - anti-virtualization: detect VmWare, ...
    - anti-dumping: erase header in memory...
    - anti tampering, via checksums
      - common: rolling checksum, CRC32, md5, sha1, adler, md4
      - others: Tiger, Whirlpool, md4, adler
- cryptor: crypts original data
  - common: bitwise operators (XOR/ROL/...), LCG, RC4, Tea
  - others: DES, AES, Blowfish, Trivium, IDEA, ElGamal

### Transformation

The original code is rewritten.

- virtualizer: turns original code into virtual code with embedded virtual machine
- mutater: alters code â€” same instruction set and architecture, but modified:
  - reflowing
  - oligomorphism

### Extra Features

- bundler: file dropping, with API hooking (to make a multi-file program run as single file)

### References

http://reverseengineering.stackexchange.com/questions/1779/what-are-the-different-types-of-packers

https://github.com/corkami/docs/blob/master/packers.pdf


## Tools

- Identify
  - PEiD
  - Exeinfo
  - [Yara rules](https://github.com/Yara-Rules/rules)
- Disassemble / Debug
  - IDA Pro / BinaryNinja / Hopper
  - OllyDbg
  - Immunity Debugger
  - x64dbg


## Automated Unpacking

Automated unpacking is possible in some cases, but such a procedure will have a fixed set of instructions and rules. As a result, automated unpacking is unlikely to work on every packer.

Some heuristics that might be used to detect that a unpacking stub has completed, and the original entry point (OEP) has taken over include:

- Execution of memory regions that are written to
- Transfer of code execution from one memory region to another
- Execution of start-up API functions
  - `LoadLibrary` and `GetProcaddress` loop
  - `GetCommandLine`
  - `GetModuleHandle`
  - `GetVersion`


## Manual Unpacking

At times automated unpacking may not succeed, OR unpacking may occur in stages interlaced with the software's core code execution. In such cases, you may have to break out your favorite Debugger and Disassembler.

### Unpacker Tail Transitions
- often (not always) found at the end of unpacking code
- Usually comes in one of the following forms:
  - jump immediate (e.g. `jmp 0401234`)
    - Jumps generally take 1 byte operand, while transitions from unpackers to application code require a larger operand (e.g. 4 bytes)
  - `push` / `ret`
    - A push followed by a return is fishy as the pushed value becomes the return address
    - The unpacker may have a constant or set a register that it jumps to
  - `pusha` / `popa`
    - Not a transition technique, but usually used for restoring registers to entry-point state
    - Hardware Breakpoint on one of the saved registers may halt debugger just before transition to OEP
      - View `ESP` in dump, select one of the 4 byte aligned values, and set bp (`F2`)

### When a tail jump is unidentifiable, attempt to locate OEP by a section hop
- Generally code resides in single section of the PE file.
- Hops between sections are unusual and occur often in the transition from unpacker stubs to application code
- OllyDump automates the search for such a hop and attempts to break when found

### Beware of self-modifying code
- How Software Breakpoints work
  - Debugger stores a copy of the byte at the breakpoint address
  - This byte is replaced with `0xCC`
  - When the address is reached, the debugger swaps in the original byte
- How self-modifying code works
  - A byte or block is read from memory
  - Optional transformations are applied
  - The byte is written (original location or elsewhere)
- Self-modify reads may read wrong (`0xCC`) byte
- Self-modify writes may overwrite breakpoints
- Use Hardware breakpoints when possible (only 4 on Intel x86 CPUs)

### Breaking on common events
- Debuggers often allow breaking on Library Load/Unload
  - Packers often end with a series of `LoadLibrary` / `GetProcAddress` calls
- Could set a breakpoint on common start-up functions
  - `GetCommandLineA`, `GetVersion`
  - Catch is they have to be loaded and available for break

## Dumping Unpacked Code

### About
Manual unpacking of an executable, as performed in a debugger, leaves the analyst in a state of with the original entry point code in memory. Although further analysis could be performed in this state, the ideal case is to create a new file that can be analyzed in a disassembler.

IDA Pro has a memory dump feature. Although useful, the data is stored in a format that is unusable by other tools.

### Process
The general process of dumping is:

1. Write a new executable from the unpacked data in memory.
1. Change the EntryPoint (EP).
1. Reconstruct the imports table.

### Tools
- [OllyDumpEx](https://low-priority.appspot.com/ollydumpex/) is a plugin for multiple debuggers (Ollydbg, Immunity Debugger, IDA Pro, WinDbg, and x64dbg).
- [Scylla Import Reconstructor](https://github.com/NtQuery/Scylla) (a standalone tool, but also comes built-in to x64dbg)
- ImpRec
- LordPE


## Exercise

`bserver.ex_`:

1. What is the OEP?
1. Which libraries are loaded for the unpacked IAT?
1. What encoding algorithm is being used?

For more examples / exercises, check out [Practical Malware Analysis](https://nostarch.com/malware) Chapter 18 [Labs](https://practicalmalwareanalysis.com/labs/) (Lab18-01, Lab18-03, and Lab18-05).
