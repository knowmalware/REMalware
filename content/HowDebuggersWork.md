# How Debuggers Work

## How Software Breakpoints Work

1. User requests a software breakpoint at an address
1. The debugger saves the byte at this address and replaces it with an 0xCC (int3)
1. Once execution reaches the address, a Breakpoint Exception occurs
1. The debugger catches the exception and alerts the user
    - Conditonal breakpoints stop only when condition is met (e.g. eax == 0)
1. Once instructed to resume, the original byte is written over the 0xCC
1. The debugger single-steps, executing the instruction
1. The original byte is saved again, and an 0xCC is placed at the address

### Side-effects

- Application code can search through memory for 0xCC
- Debugger overhead slows execution
    - Timing checks can identify debugger
- Self-modifying code will assume 0xCC is the original content and read/modify/write it


## How Hardware Breakpoints Work

Less obtrusive than software bps, hardware breakpoints use the debug registers which can only be set in privileged mode (ring 0).

1. User requests a hardware breakpoint at an address
    - Uses the linear/virutal address assuming an OS that uses paging
    - Can be local (this process only) or global (all processes)
1. If available, the debugger sets a debug register (dr0-dr3)
1. Once reached, a Single-Step Exception occurs
1. The debugger catches the exception and alerts the user
1. The user may resume execution.

### Weakness

Code that runs in Ring 0, such as an exception handler, could clear or alter the debug register.
